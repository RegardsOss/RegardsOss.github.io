---
layout: classic-docs
title: REGARDS Feature Management API
---

> Draft - Details may still change but not the main principles!
{: .tip .warning}

{% include toc.md %}

## Overview

`Feature management` microservice is a data repository in [GeoJSON format](https://geojson.org/).

`Feature Management` reponsabilities:

* Create, patch or Delete data references,
* Delegate the storage of files (if any) to `Storage Management`.

To edit this repository, a data producer has to send **edit requests**.

At the moment, 2 API are available :

* Messaging API ([AMQP](https://www.amqp.org/)) allows to publish creation, patch or deletion requests on specific exchanges.
* HTTP REST API allows to submit creation requests (as `POST` HTTP requests), update requests (as `PATCH` HTTP requests) or deletion requests (as `DELETE` HTTP requests).

![Feature management architectural concepts](/assets/schemas/feature_management/architectural_concepts_fem.png)

API are documented in detail below.

## Request payload

Regardless of the API used, payload of each API is expected in [GeoJSON format](https://geojson.org/).

The basic structure is as follows :

* A required `id`,
* A required `type` with value `Feature`,
* An optional [geometry in GeoJSON format](https://tools.ietf.org/html/rfc7946#section-3.1),
* An optional set of `properties`.

```json
{
    "id": "FeatureId",
    "type": "Feature",
    "geometry": {
        "type": "Point",
        "coordinates": [
            125.6,
            10.1
        ]
    },
    "properties": {
        "name": "Dinagat Islands"
    }
}
```

For the purposes of this microservice, GeoJSON structure is extended  with following properties :

* An `urn` (uniform resource name as unique identifier) generated by the microservice when creating a new reference and **expected only** when updating a reference.
* A required `model` representing the name of the model defining the expected `properties` field structure (and previously configured).
* A required `entityType` defining the reference business type.
* An optional `files` property with a fixed structure that allows to store or reference physical data (service delegated to another microservice called `Storage Management`).

```json
{
    "id": "FeatureId",
    "urn": "UniqueFeatureId",
    "model": "RelatedModelName",
    "entityType": "DATA",
    "type": "Feature",
    "geometry": {
        "type": "Point",
        "coordinates": [
            125.6,
            10.1
        ]
    },
    "properties": {
        "name": "Dinagat Islands"
    },
    "files": [
        {
            "locations": [
                {
                    "storage": "DISK",
                    "url": "file://home/user/regards/file.zip"
                }
            ],
            "attributes": {
                "dataType": "RAWDATA",
                "mimeType": "application/zip",
                "filename": "file.zip",
                "filesize": "8013",
                "algorithm": "MD5",
                "checksum": "4e188bd8a6288164c25c3728ce394927"
            }
        }
    ]
}
```

<a name="payloadppt"></a>

### Payload detailed properties

#### Feature

|Path|Type|Description|Optional|
|:--:|:--:|:---------:|:------:|
|id| `String` |Id from provider||
|urn| `String` |Unique feature identifer based on provider identifier with versionning ||
|model| `String` |Indicate which custom model will be used to validate properties||
|entityType| `String` |COLLECTION, DATA, DATASET||
|type| `String` |FEATURE||
|geometry| `Object` |GeoJson coordinates|true|
|properties| `Array` |Custom properties structured according to the specified model||
|files| `Array` | List of physical files to store or reference | true |
{:.table.table-striped}

> Urn is only expected in update request!
{: .tip .important}

#### Files

|Path|Type|Description|Optional|
|:--:|:--:|:---------:|:------:|
|locations[].storage| `String` |Storage|true|
|locations[].url| `String` |Url location||
|attributes.dataType| `String` |RAWDATA, QUICKLOOK_SD, QUICKLOOK_MD, QUICKLOOK_HD, DOCUMENT, THUMBNAIL, DESCRIPTION||
|attributes.mimeType| `String` |MIME type||
|attributes.filename| `String` |Filename||
|attributes.filesize| `Number` |File size|true|
|attributes.algorithm| `String` |Checksum algorithm|true|
|attributes.checksum| `String` |Checksum|true|
{:.table.table-striped}

> Algorithm & cheksum are required if data have to be stored by `Storage Management`.
{: .tip .important}

## Request metadata

As the payload, regardless of the API used, metadata has to be associated with each request. 

### Metadata detailed properties

|Path|Type|Description|Optional|
|:--:|:--:|:---------:|:------:|
|metadata.session| `String` |Arbitrary session name to classify data for human operators||
|metadata.sessionOwner| `String` |Arbitrary session owner to classify data for human operators||
|metadata.storages| `Array` |Target storages if there are files to store (may be empty!)| true|
|metadata.storages[].pluginBusinessId| `String` |Storage plugin identifier (previously configured in `Storage Management`||
|metadata.storages[].targetTypes| `Array` |List of data object types accepted by this storage location| true|
|metadata.storages[].storePath| `String` |Directory in which to store the file| true|
|metadata.priority| `String` |HIGH, NORMAL, LOW||
{:.table.table-striped}

## REST API

For creation and update requests, REST API is expected a GeoJSON collection extended with specific metadata.

The structure is as follows :

* Required `metadata` that apply to **all features**,
* A required `type` with value `FeatureCollection`,
* Required `features` containing a set of [GeoJson feature](#payloadppt).

Example of feature creation collection:

```json
{
    "metadata": {
        "session": "session",
        "sessionOwner": "owner",
        "storages": [
            {
                "pluginBusinessId": "disk"
            }
        ],
        "priority": "NORMAL"
    },
    "features": [{}, {}, {}],
    "type": "FeatureCollection"
}
```

Example of feature update collection:

```json
{
    "metadata": {
        "storages": [
            {
                "pluginBusinessId": "disk"
            }
        ],
        "priority": "NORMAL"
    },
    "features": [{}, {}, {}],
    "type": "FeatureCollection"
}
```

> Session & session owner are not supported in update metadata!
{: .tip .important}

### Feature Creation request example

#{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureCreationRequest/http-request.md %}

{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureCreationRequest/request-body.md %}

#{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureCreationRequest/http-response.md %}

API return maps of granted and denied requests :

* Granted property maps feature id to its related request id and allows the producer to optionnaly monitor request lifecycle listening to request event.
* Denied property maps feature id to a list of rejection causes.

### Feature Patch request example

#{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureUpdateRequest/http-request.md %}

{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureUpdateRequest/request-body.md %}

#{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureUpdateRequest/http-response.md %}


API return maps of granted and denied requests :

* Granted property maps feature urn to its related request id and allows the producer to optionnaly monitor request lifecycle listening to request event.
* Denied property maps feature urn to a list of rejection causes.

## AMQP API

For creation and update requests, AMQP API is expected a message containing an edition request.

The structure is as follows :

* A required `requestId` for request monitoring (max 36 characters long),
* A required `requestDate` in ISO 8601 date format (a past date is required!),
* Required `metadata`,
* A required `feature` (look at [payload description above](#payloadppt))

Furthermore, all message is wrapped to manage the tenant context :

* `tenant` property must contain an existing tenant,
* `content` property must contain the payload.

```json
{
    "tenant": "tenant",
    "content": {
        "requestId": "70970463-0f6b-4488-b58c-52af3f7e9563",
        "requestDate": "2019-04-22T01:03:00",
        "metadata": {
            "sessionOwner": "owner",
            "session": "session",
            "storages": [
                {
                    "pluginBusinessId": "disk"
                }
            ],
            "priority": "NORMAL"
        },
        "feature": {
            "id": "FeatureId",
            "urn": "UniqueFeatureId",
            "model": "RelatedModelName",
            "entityType": "DATA",
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": [
                    125.6,
                    10.1
                ]
            },
            "properties": {
                "name": "Dinagat Islands"
            },
            "files": [
                {
                    "locations": [
                        {
                            "storage": "DISK",
                            "url": "file://home/user/regards/file.zip"
                        }
                    ],
                    "attributes": {
                        "dataType": "RAWDATA",
                        "mimeType": "application/zip",
                        "filename": "file.zip",
                        "filesize": "8013",
                        "algorithm": "MD5",
                        "checksum": "4e188bd8a6288164c25c3728ce394927"
                    }
                }
            ]
        }
    }
}
```

### Feature Creation request message

Message has to be published on this exchange : `regards.broadcast.fr.cnes.regards.modules.feature.dto.event.in.FeatureCreationRequestEvent`

With following headers:

|Header|Value|
|:--:|:---------:|
|\__ctype__| GSON|
|\__tenant__| The tenant|
|\__gson\_wrapped\_type__|fr.cnes.regards.modules.feature.dto.event.in.FeatureCreationRequestEvent|
{:.table.table-striped}

#### Creation message example

{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureCreationRequest/request-message.md %}

### Feature Patch request message

Message has to be published on this exchange : `regards.broadcast.fr.cnes.regards.modules.feature.dto.event.in.FeatureUpdateRequestEvent`

With following headers:

|Header|Value|
|:--:|:---------:|
|\__ctype__| GSON |
|\__tenant__| The tenant|
|\__gson\_wrapped\_type__| fr.cnes.regards.modules.feature.dto.event.in.FeatureUpdateRequestEvent|
{:.table.table-striped}

#### Patch message example

{% include_relative generated-snippets/FeatureControllerIT/testCreateValidFeatureCreationRequest/request-message.md %}

## AMQP monitoring API

`Feature management` microservice publishes request messages to monitor request lifecycle.

Messages are published on this exchange : `regards.broadcast.fr.cnes.regards.modules.feature.dto.event.out.FeatureRequestEvent`

Structure of the message is as follows :

* The `requestId`,
* The related feature `id`,
* The related feature `urn`,
* The state of the request (`GRANTED`,`DENIED`,`ERROR` or `SUCCESS`),
* A list of `errors` if any.

```json
{
    "tenant": "tenant",
    "content": {
        "requestId": "12345463-0f6b-4488-b58c-52af3f7e9563",
        "id": "MyId",
        "urn": "URN:FEATURE:DATA:tenant:87fdda0e-27d1-494f-a1c0-c57f2f0810f7:V1",
        "state": "SUCCESS",
        "errors": []
    }
}
```

> To receive these messages, your have to subscribe to this exchange.
{: .tip .info}

> If AMQP virtual host mode is set to `SINGLE`, this exchange will receive all messages of all tenants! So the receiver may have to filter them according to the tenant he wishes to manage.
{: .tip .warning}
