---
layout: classic-docs
title: REGARDS Frontend Plugins
short-title: Plugins
---

* automatic table of content
{:toc}

# Presentation

REGARDS UI plugins are pieces of Javascript files bundled together that can be added dynamically into the user interface. 
They allow administrators creating dedicated HMI parts depending on data handled by the project.

There are currently two types of plugins:
* `criterion`: Used in the search form, that type of plugin allows users creating search filters on attributes. See [criteria plugins](/frontend/plugins/plugin-criteria/) page for more detail
* `services`: Used in the search results view, that type of plugin provide additionnals interactions with data they are associated with. The developer can ask both administration (configuration) and user (runtime configuration) to fill several values before computing and displaying service results in a dialog box. See [service plugins](/frontend/plugins/plugin-services/) page for more detail

Plugins are very similar to REGARDS UI dynamic modules, but:
* They are not bundled along the core source code. Instead, they are compiled separetely and should be loaded through an HTTP repository.
* They accept administrator and user parameters whereas dynamic modules accept only an administror configuration

The following sections will present common points to all plugin types.

# Create a new plugin

You can create a new plugin using the yeoman generator `generator-regards-ui-plugin` provided with sources into `webapp/yeoman/generator-regards-ui-plugin`.  
To install and use the generator, open a terminal in rs-frontend project then run the following commands:

```bash
$ cd webapp/yeoman/generator-regards-ui-plugin
$ npm install -g
$ npm install -g yo
$ cd ../../plugins
$ yo regards-ui-plugin
```

Yeoman will ask you several parameters to generate the new plugin, depending on the choosen type. Once finished, the plugin folder is iniatialized with some basic examples.  

# Plugin folder structure

The following folder structure is generated by Yeoman. It matches REGARDS standard structure.
 ```
 ├── node_modules        : Installed node modules from package JSON
 ├── reports             : Built reports for coverage and tests
 ├── src                 : Plugin main source folder
 |   ├── clients         : Plugin redux API clients
 |   ├── components      : Plugin React components
 |   ├── containers      : Plugin React containers
 |   ├── i18n            : Plugin internationalization
 |   ├── styles          : Plugin graphic styles
 |   ├── main.js         : Plugin exported index
 |   ├── plugin-info.js  : Plugin definition  
 |   └── reducer.js      : Redux reducers builder
 ├── target              : Built sources for plugins  
 ├── tests               : Plugin tests source folder
 ├── package.json        : Npm module file describing plugin module
 ├── README.md           : Plugin README
 └── webpack.<mode>.js   : Webpack files for plugin building 
```

*Note: node_modules, reports and target folders may not be present initially, as they are build folders. Some other folders or files, like clients or reducer.js, are not initially created. Indeed they should be added by developer on need.*

# Build commands

A plugin, by default, defines at least, in package.json, the following commands.
Note: rs-frontend repository must have been installed before running any of the commands below (see [Setup page](/frontend/setup/)), as it provides the core webpack DLLs, used to optimize compilation duration and bundle size.

## Compilation

Compiles the plugin into a usable plugin bundle

```bash
$ npm run build:dev
$ npm run build:watch
$ npm run build:prod
```
Command modes:
* `build:dev`: Builds the bundle once for development
* `build:watch`: Watches for code changes. Triggers `build:dev` on detection
* `build:prod`: Builds the bundle once for production

## Tests

Runs any `*.test.js` / `*.test.jsx` file in `/tests` folder.

```bash
$ npm run test
$ npm run test:watch
$ npm run test:coverage
```
Command modes:
* `test` or `test:mocha`: Runs all tests once and shows tests results
* `test:watch`: Watches for code changes. Triggers `test:mocha` on detection
* `test:coverage`: Runs tests and creates a coverage report

## Lint

Applies lint rules to `src` and `tests` folders then displays an issues report.

```bash
$ npm run lint
$ npm run lint:fix
```

Command options:
* `lint:fix`: Attempts to correct issues.

## Utils

Additionaly, some scripts are provided in `rs-frontend/webapp/scripts` folder.

```bash
$ ./scripts/build-all-plugins dev criterion
$ ./scripts/test-all-plugins services
$ ./scripts/lint-all-plugins all
$ ./scripts/compareDependencies.js ./package.json ./plugins/criterion/string/package.json
```
Available scripts:
* **build-all-plugins**: Builds all plugins found in `rs-frontent/webapp/plugins` (can be restricted with parameters)
* **test-all-plugins**: Tests all plugins found in `rs-frontent/webapp/plugins` (can be restricted with parameters)
* **lint-all-plugins**: Lints all plugins found in `rs-frontent/webapp/plugins` (can be restricted with parameters)
* **compareDependencies**: Compares dependencies of the first and second package.json files as parameters (helps upgrading plugin dependencies versions when core dependencies changed)

# Deploy plugin

In production, the plugin bundle, must be deployed in a plugin reposity, i.e. an accessible URL from front-end. The production build commands, see previous sections, produces the plugin bundle in `target/prod/plugin.js`. That file must be copied in the `/plugins` repository of `rs-frontend microservice` - the actual path depends on server configuration of REGARDS instance.   
Then, trough the administrator interface, the plugin must be declared in "User interface / Plugins", providing a plugin path like `/plugins/my-plugin/plugin.js`.  
Finally, the plugins instances, called `plugin configurations`, can be created, either in search-form modules, for criteria, or in "User interface / Services" for services.

*Note: In development mode, Webpack dev server acts as the plugin repository. Therefore, only the plugin declation and configuration creation are required.*

# Implementation

## Plugin entry point

 The entry point of a plugin is `main.js` file. It describes all required information to load and display the plugin.  
 The `initPlugin` method is used to bundled easily that information.
 
 ```js
initPlugin(<ReactComponent>, <React-redux reducers builder>, <i18nmessages>, <pluginInfo>)
```
- `ReactComponent` : The main React component to display your plugin
- `React-redux reducers builder` : Not mandatory (can be null), a function taking plugin instance ID as parameter and returing a map of reducer field to reducer function (see [Redux management](#redux-management) section)
- `i18nmessages` : Internationalization messages as an object with languages as keys (en|fr).
- `pluginInfo` : The plugin-info.json object


## plugin-info.json

This file is used by the plugin loader to define the configuration required by the plugin.

```json
{
  "name": "my-plugin",
  "description": "It is my plugin",
  "version" : 1.0,
  "author" : "Someone",
  "company" : "Some company",
  "email" : "someone@some-company.com",
  "url" : "www.my-plugin-is-awesome.com",
  "license": "GPL-V3",
  "type" : "CRITERIA",
  "conf" : {}
}

```
Notes: 
 * `type` field marks the plugin type (criterion or service plugin) 
 * `conf` field content is specific to the plugin type

## Plugin configuration view

Plugin configuration panels are *automatically created by the main application*, using plugin-info.json . Therefore, the *plugin developers will never implement plugin configuration views*.

## Plugin user view

Main react component, exported as the first parameter of the `initPlugin` method, within `main.js`, is the first displayed component after loading.

The here under properties are provided at runtime by the plugin loader to the main component :
```js
propTypes = {
    /**
     * Plugin unique identifier provided by the plugin loader
     */
    pluginInstanceId: React.PropTypes.string.isRequired,
  }
```

*Note: other plugin properties are specific to the plugin type, see [criterion](/frontend/plugins/plugin-criteria/) or [service](/frontend/plugins/plugin-services/) plugin pages for more detail.*

## Redux management in plugins

Plugins can, optionally, export reducers to be able using and updating their own space in Redux store. In REGARDS, components usually manage a static Redux store space. However, as one plugin can be instantiated many times, such system would result in all plugin instances sharing the same Redux store space, and thus the same state. Therefore, plugins have to address a *dynamic* Redux store.  
For that reason, `initPlugin` expects to receive an optional `buildReducer` method, and not a static reducers map. That method must return, *given the unique `pluginInstanceId`*, the plugin reduce methods map.

### Building reducers

The plugin buildReducer function aims at providing a different dynamic reducers for each plugin instance. Therefore it must use `pluginInstanceId` parameter to generate unique reducers namespaces. That way, the system ensures plugin instance 1 will not reduce plugin instance 2 Redux actions and reciprocally.

*Build plugin reducers function example (might be placed in reducer.js file):*
```jsx
  // ...
/*  
 * Build reducer function 
 * @param {string} pluginInstanceId plugin instance ID, must be used to generate unique namespaces and store paths
 * @return {*} reducers configuration for plugin instance
 */
export default function buildReducer(pluginInstanceId) {
  return {
    myModel1: getMyModel1Client(pluginInstanceId).reducer,
    myModel2: getMyModel2Client(pluginInstanceId).reducer,
  }
}
```

*An example is available in enumerated criterion, at path webapp/plugins/criterion/enumerated/src/reducer.js*

### Building actions and selectors

Redux actions must also be dynamically built using pluginInstanceID, since the namespace is used by plugin reducer to filter actions it should handle and ignore.  
Furthermore, as the redux store space are separated, the selectors must also be dynamic. The selectors path contains the two elements below:
* First path element: `**{Plugin name}**.**{Plugin instance ID}**` where plugin name matches name from plugin-info.json and plugin instance ID is the value provided to both buildReducer method and main component.
* Second path element is the reducer map key in the value returned by buildReducer method (myModel1 or myModel2 in example before)

Since the plugin instance ID is provided to the main component, it is possible to write the following code:
```jsx
  class MyPluginContainer extends React.Component {
  static mapStateToProps(state, { pluginInstanceId }) {
      return {
        myValue: new MyModel1Selectors(pluginInstanceId).getMyValue(state)
      }
    }
```
However, that approach is *considered a bad practice*, as selectors and actions would be instantiated each time mapStateToProps and mapDispatchToProps are called, what could in end consume lot of browser memory.
To solve that issue, REGARDS provides the `PluginsClientsMap` class, that is a lazy clients map. Using it *avoids creating new actions and selectors instances each time mapStateToProp and mapDispatchToPropsToProps are called*.


```jsx
  class MyPluginContainer extends React.Component {
    // That map will hold the instances of actions and selectors
    static CLIENTS_MAP = new PluginsClientsMap()

    static mapStateToProps(state, { pluginInstanceId }) {
      const mySelectors = MyPluginContainer.CLIENTS_MAP.getClient(buildMyClient, pluginInstanceId).selectors  
      return {
        myValue: mySelectors.getMyValue(state)
      }
    }

    static mapDispatchToPropsToProps(dispatch, { pluginInstanceId }) {
      const myActions = MyPluginContainer.CLIENTS_MAP.getClient(buildMyClient, pluginInstanceId).actions  
      return {
        dispatchSomething: () => dispatch(myActions.doSomething())
      }
    }

```

*Note: The PluginsClientsMap is a simple tool that buffers a map on pluginInstanceId => builder => builtValue. It is very straightforward code and can be replaced by a locally coded buffer if you prefer. In order to work correctly, it requires clientBuilder instance - buildMyClient in previous example - to be a constant JS function reference for a single client.*
